<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>IPTV Manager — Monitor e Reparo</title>
  <style>
    body { font-family: Arial, sans-serif; padding:12px; background:#f6f6f8; color:#222; }
    #app { max-width:900px; margin:0 auto; }
    header { display:flex; gap:12px; align-items:center; }
    input, button, select { padding:8px; border-radius:6px; border:1px solid #ddd; }
    table { width:100%; border-collapse:collapse; margin-top:12px; background:#fff; }
    th,td { padding:8px; border-bottom:1px solid #eee; text-align:left; }
    tr.down { background: #ffecec; }
    .small { font-size:12px; color:#666; }
    .log { white-space:pre-wrap; font-family:monospace; background:#111; color:#efe; padding:8px; border-radius:6px; max-height:200px; overflow:auto; }
  </style>
</head>
<body>
  <div id="app">
    <header>
      <h2>IPTV Manager</h2>
      <div class="small">Monitora clientes e troca IPTV quando cair</div>
    </header>

    <section style="margin-top:10px;">
      <label>Base URL da API: <input id="baseUrl" value="https://netplay.sigma.vin/api" style="width:350px"></label>
      <label style="margin-left:8px">Token (recomendado): <input id="apiToken" placeholder="se tiver, cole aqui" style="width:250px"></label>
      <button id="btnLogin">Testar / Salvar</button>
    </section>

    <section style="margin-top:10px;">
      <label>Intervalo polling (seg): <input id="pollSec" value="15" style="width:70px"></label>
      <label style="margin-left:8px">Filtro status considerado "caído": <input id="downStatus" value="offline" style="width:120px"></label>
      <button id="btnStart">Iniciar Monitor</button>
      <button id="btnStop" disabled>Parar</button>
    </section>

    <section style="margin-top:12px;">
      <table id="customersTable" aria-live="polite">
        <thead><tr><th>ID</th><th>Nome</th><th>IPTV</th><th>Status</th><th>Ações</th></tr></thead>
        <tbody></tbody>
      </table>
    </section>

    <section style="margin-top:12px;">
      <h4>Logs</h4>
      <div id="log" class="log"></div>
    </section>
  </div>

  <script>
  // --- CONFIG HELP ---
  // Este template usa endpoints fictícios:
  // GET  {BASE_URL}/customers            -> lista clientes (paginação opcional)
  // GET  {BASE_URL}/customers/:id/status -> status do cliente
  // POST {BASE_URL}/customers/:id/iptv   -> altera configuracao iptv (body: {profile: "..."} ou o que sua API pedir)
  //
  // Substitua conforme a API real do seu painel.

  const el = id => document.getElementById(id);
  const logEl = el('log');
  const tableBody = document.querySelector('#customersTable tbody');

  function log(...args){
    const now = new Date().toLocaleString();
    logEl.textContent = `[${now}] ` + args.map(a => (typeof a === 'object' ? JSON.stringify(a) : a)).join(' ') + '\n' + logEl.textContent;
  }

  function getAuthHeaders(){
    const token = el('apiToken').value.trim();
    if(token) return { 'Authorization': 'Bearer ' + token, 'Content-Type': 'application/json' };
    // fallback: basic auth from prompt (not stored)
    return { 'Content-Type': 'application/json' };
  }

  async function fetchCustomers(){
    const base = el('baseUrl').value.trim();
    const url = base + '/customers';
    log('Buscando clientes em', url);
    try {
      const res = await fetch(url, { headers: getAuthHeaders() });
      if(!res.ok) throw new Error('Erro ' + res.status);
      return await res.json(); // espere array de clientes
    } catch(err){
      log('Erro fetchCustomers:', err.message);
      return [];
    }
  }

  async function fetchCustomerStatus(id){
    const base = el('baseUrl').value.trim();
    const url = base + '/customers/' + encodeURIComponent(id) + '/status';
    try {
      const res = await fetch(url, { headers: getAuthHeaders() });
      if(!res.ok) throw new Error('Status fetch erro ' + res.status);
      return await res.json(); // formato: {status: 'online'|'offline', lastSeen: '...'}
    } catch(err){
      log('Erro fetchCustomerStatus', id, err.message);
      return { status: 'unknown' };
    }
  }

  async function changeIptv(id, newProfile){
    const base = el('baseUrl').value.trim();
    const url = base + '/customers/' + encodeURIComponent(id) + '/iptv';
    log('Alterando IPTV do', id, '->', newProfile);
    try {
      const res = await fetch(url, {
        method: 'POST',
        headers: getAuthHeaders(),
        body: JSON.stringify({ profile: newProfile })
      });
      if(!res.ok) {
        const txt = await res.text().catch(()=>'');
        throw new Error('Erro ' + res.status + ' ' + txt);
      }
      const data = await res.json();
      log('Alterado', id, data);
      return data;
    } catch(err){
      log('Erro changeIptv', id, err.message);
      throw err;
    }
  }

  // UI helpers
  function renderCustomers(list){
    tableBody.innerHTML = '';
    list.forEach(c => {
      const tr = document.createElement('tr');
      tr.className = (c.status === el('downStatus').value.trim() ? 'down' : '');
      tr.innerHTML = `
        <td>${c.id}</td>
        <td>${c.name || c.customer_name || ''}</td>
        <td>${c.iptv_profile || c.profile || ''}</td>
        <td>${c.status || 'unknown'}</td>
        <td>
          <select data-id="${c.id}" class="profileSelect">
            <option value="">-- escolher --</option>
            <option value="profileA">profileA</option>
            <option value="profileB">profileB</option>
            <option value="reconnect">reconnect</option>
          </select>
          <button data-id="${c.id}" class="btnChange">Aplicar</button>
        </td>
      `;
      tableBody.appendChild(tr);
    });
  }

  // Manual change handler
  tableBody.addEventListener('click', async (ev) => {
    const btn = ev.target.closest('.btnChange');
    if(!btn) return;
    const id = btn.dataset.id;
    const sel = tableBody.querySelector(`select[data-id="${id}"]`);
    const profile = sel.value;
    if(!profile) return alert('Escolha um perfil');
    try {
      await changeIptv(id, profile);
      alert('Solicitação enviada com sucesso');
    } catch(e){ alert('Erro: ' + e.message); }
  });

  // Main monitoring loop
  let monitorInterval = null;
  let customersCache = [];

  async function tickMonitor(){
    // 1) obter lista de clientes
    const all = await fetchCustomers();
    // assume formato array [{id, name, iptv_profile, status}]
    customersCache = all;
    // 2) opcional: atualizar status individual (se API separar)
    for(const c of customersCache){
      const s = await fetchCustomerStatus(c.id).catch(()=>({status:'unknown'}));
      c.status = s.status || c.status || 'unknown';
    }
    renderCustomers(customersCache);

    // 3) detectar "caídos" e tentar ação automática
    const downLabel = el('downStatus').value.trim();
    for(const c of customersCache){
      if(c.status === downLabel){
        log('Detectado CAÍDO:', c.id, c.name);
        // decidir ação automática: trocar para profileB -> você pode ajustar a lógica
        try {
          // Exemplo: alterna entre dois perfis
          const newProfile = (c.iptv_profile === 'profileA') ? 'profileB' : 'profileA';
          await changeIptv(c.id, newProfile);
          log('Auto-troca feita para', c.id, newProfile);
        } catch(err){
          log('Falha ao auto-trocar', c.id, err.message);
        }
      }
    }
  }

  // Controls
  el('btnStart').addEventListener('click', async () => {
    const sec = parseInt(el('pollSec').value) || 15;
    el('btnStart').disabled = true; el('btnStop').disabled = false;
    await tickMonitor(); // primeira execução imediata
    monitorInterval = setInterval(tickMonitor, sec*1000);
    log('Monitor iniciado (intervalo', sec, 's)');
  });

  el('btnStop').addEventListener('click', () => {
    if(monitorInterval) clearInterval(monitorInterval);
    monitorInterval = null;
    el('btnStart').disabled = false; el('btnStop').disabled = true;
    log('Monitor parado');
  });

  // Testar / salvar: apenas testa a conexão
  el('btnLogin').addEventListener('click', async () => {
    const base = el('baseUrl').value.trim();
    try {
      const res = await fetch(base + '/ping', { headers: getAuthHeaders() });
      if(res.ok) { alert('Conexão OK'); log('Ping ok'); }
      else { alert('Ping falhou: ' + res.status); log('Ping falhou', res.status); }
    } catch(e){ alert('Erro conexão: ' + e.message); log('Erro ping', e.message); }
  });

  // inicializa
  log('IPTV Manager pronto. Lembre de ajustar endpoints e headers conforme sua API.');
  </script>
</body>
</html>